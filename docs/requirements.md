# 要件整理 (OnSiteLogistics)

この文書は OnSiteLogistics プロジェクトの要件、検討状況、決定事項、未決課題を整理するためのものです。更新時は `docs/documentation-guidelines.md`（ツール管理システム）に従い、重複記載を避けつつ一次情報をここに集約します。

## 1. 背景
- 小規模金属加工工場では、材料が構内に入り複数工程を経て部品になる。加工途中の部品は都度置き場が変わる。
- 各部品には紙の移動票が添付されており、部品番号または製造オーダー番号のバーコードで識別される。
- 現状は所在確認に手間がかかり、サイネージ等でリアルタイムに可視化して効率化したい。

## 2. 目標
- ハンディリーダで部品票と棚のバーコードを順番に読み取り、所在を記録できる仕組みを構築する。
- 読み取った情報を工場内のローカルサーバーへ送信し、サイネージ画面に各部品の最新所在を表示する。
- どこに何があるかを随時把握できるようにし、現場作業のムダ探索や確認作業を減らす。

## 3. 想定ユーザーと利害関係者
- **現場スタッフ**: ハンディリーダを携帯し、部品の移動と棚登録を行う。
- **製造管理担当**: サイネージやダッシュボードで所在を確認し、工程の進捗管理を行う。
- **システム管理者**: Raspberry Pi やサーバーの運用・保守を担当。

## 4. システム構成の現時点案
- **入出力デバイス**: ハンディバーコードスキャナを Raspberry Pi Zero 2 W に USB OTG で接続。
- **通信経路**: Pi から工場内のローカル LAN サーバーへ Wi-Fi (2.4 GHz) で HTTP POST。サーバーは所在データを蓄積し、サイネージへ提供。
- **UI ディスプレイ**: Waveshare 2.13″ e-Paper HAT (V4) を装着し、2回スキャンの進捗と送信結果を表示。
- **電源**: モバイルバッテリーによる携帯運用。Pi Zero 2 W + USB スキャナの合計消費 0.4–0.8 A (5 V) を前提に、10,000 mAh クラスで 8–16 時間稼働を目標。
- **運用**: systemd サービス化で電源投入即起動。ネットワーク断時はローカルキューで再送。

## 5. 操作フロー (現時点の想定)
1. 現場スタッフがスキャナを起動し、部品票のバーコード（部品番号または製造オーダー番号）を読み取る。
2. 続けて設置先の棚バーコードを読み取る。
3. Pi 側で「2回で1件」として状態遷移 (WAIT_A → WAIT_B → COMMIT) を管理し、順序エラーやタイムアウト時はリセット。
4. 取得情報を JSON 化してサーバーへ送信し、応答 200 をもって完了とする。通信不可の場合は再送キューに保存。
5. サーバーは所在情報を更新し、サイネージに最新の部品位置を表示。

## 6. デバイス設計メモ
- **スキャン順序のフィードバック**:
  - 電子ペーパーに 3 行で「A読取」「B読取」「送信状態」を表示し、各行を部分更新（約 0.42 s）。
  - 補助として三色 LED やブザーを付け、状態遷移を光・音でも通知する案あり。
  - エラー時は赤点灯＋長音、成功時は緑点滅＋短音など、現場でも直感的に理解できるパターンを検討。
- **入力方式**:
  - スキャナが USB シリアル (CDC-ACM) モードを提供する場合は `/dev/ttyACM*` 経由で受信し、行単位で処理。
  - HID キーボードとしてしか動作しない場合は evdev で直接読み取って状態管理。
  - バーコード内容に接頭辞（例: `A:xxxxx`, `B:yyyyy`）を付与して順序検証する運用が推奨。
- **電子ペーパー仕様**:
  - Waveshare 2.13″ e-Paper HAT V4 (白黒 250×122)。全更新 ~3 s、快速更新 ~1.5 s、部分更新 ~0.42 s。
  - 部分更新を 5 回連続したら全更新を挟んで残像をリセットする。
  - BUSY ピンで描画完了を待機し、ゴースト対策を徹底。

## 7. 購入・使用予定機材
- Raspberry Pi Zero 2 W（既存想定）。
- USB ハンディバーコードスキャナ（CDC-ACM 切替可が望ましい）。
- Waveshare 2.13″ e-Paper HAT V4（STEMDIY ブランド取扱品。購入予定とユーザー合意済み）。
- モバイルバッテリー（5 V / 2 A 以上の出力）。
- 三色 LED、ブザー、キャンセル用ボタン（またはキャンセル用バーコード）。

## 8. 進め方のステップ
- **Step 1（完了）**: 電子ペーパー (2.13″ V4) を Pi Zero 2 W から駆動し、Waveshare テストコードで表示確認する。`docs/handheld-reader.md` のセットアップログ 2025-02-15 を参照。
- **Step 2（完了）**: ハンディスキャナ単体の入力確認（CDC-ACM 優先、HID でも動作させる）。`scan_test.py` で HID 入力を文字列化済み。
- **Step 3（完了）**: スキャナ入力と電子ペーパー表示を統合し、A→B→完了フローをローカル完結させる。`scripts/handheld_scan_display.py` に状態機械を実装し、`Status: DONE` 表示まで確認済み。
- **Step 4（完了）**: サーバー通信（HTTP POST）とローカル再送キューを実装。`scripts/handheld_scan_display.py` が `/api/v1/scans` へ送信し、通信断時は `~/.onsitelogistics/scan_queue.db` で再送管理する。ウィンドウA（tool-management-system02 `feature/scan-intake`）側で `part_locations` テーブル upsert と `Socket.IO` 配信の自動更新まで動作確認済み。
- **Step 5（進行中）**: サイネージ表示／ダッシュボードの仕様策定と実装。WindowAB 右ペインへの所在一覧タブ導入を完了し、WindowC 連携方式を検討中。

## 9. 未決・検討事項
- サイネージ表示方法（表示デバイス・UI）と WindowC 連携方式（Socket.IO / REST / 共有ファイル）。
- バーコード体系の詳細（部品番号とオーダー番号のフォーマット、棚バーコードの規模）。
- オフライン時の運用ルール（再送に失敗した場合の現場フロー）。
- バッテリー交換サイクルや充電ステーションの運用設計。
- Pi デバイスのハードケース、保護具合・現場での耐久性。
- 電子ペーパーの更新頻度と長期運用による劣化への対策。
- MJ2818A スキャナのシリアル（USB-COM/CDC-ACM）対応有無。現状は HID で稼働中だが公式資料で切替コードが未確認。シリアル運用が必要ならメーカーへの確認が必要。

## 11. サーバー連携（ウィンドウA）要件案
- **基本方針**: OnSiteLogistics 側はハンディリーダからの最小情報のみ送信し、ウィンドウA（tool-management-system02）側でデータ蓄積・通知・サイネージ連携を担う。双方向通信は基本的に無し（必要最低限の応答のみ）。
- **API インターフェース（案）**
  - エンドポイント: `POST /api/v1/scans`（JSON）
  - ヘッダ: `Authorization: Bearer <shared_token>`（shared token で十分。後続で相互認証が必要なら調整）
  - リクエストボディ例:
    ```json
    {
      "scan_id": "20250215-00123",          // Pi 側で生成（時刻＋連番など）
      "device_id": "pi-zero2w-01",
      "part_code": "TEST-002",
      "location_code": "SHELF-05",
      "scanned_at": "2025-02-15T07:12:34Z",  // UTC ISO8601
      "sequence": {"order": ["A", "B"]},     // 2回読みの順序情報
      "retries": 0                           // 再送時は increment
    }
    ```
  - レスポンス（200 OK）:
    ```json
    {
      "accepted": true,
      "server_received_at": "2025-02-15T07:12:35Z"
    }
    ```
    - `accepted=false` や 4xx/5xx 時は、Pi 側でローカルキューに残して再送。
- **サーバー挙動（実装済み）**:
  - `part_locations` テーブルへの upsert、および `Socket.IO` の `part_location_updated` ブロードキャストで所在一覧をリアルタイム更新。
  - REST フォールバックとして `/api/part_locations?limit=200` を提供。UI では自動更新に失敗した際 20 秒間隔で再取得する。
- **再送方針**: Pi 側で SQLite に保存し、成功応答を得るまで指数バックオフで再送。一定回数失敗で Status 表示に「QUEUED/ERROR」を掲示して現場通知。
- **セキュリティ / ネットワーク**: 工場内ローカル LAN (WPA2) での運用を前提。API トークンは `/etc/onsitelogistics/credentials.json` などに保存し、Git 管理対象外。HTTPS 利用可否はウィンドウAの環境に依存（可能であればリバースプロキシ経由で TLS 終端）。
- **ログ共有**: サーバーからの応答内容は `handheld_scan_display.py` 側で INFO ログに残し、必要に応じて `docs/handheld-reader.md` に運用手順を追記する。
- **既存インフラとの整合**: ウィンドウA は Flask ベースの 3 ペイン UI を持ち、Docker Compose 上で PostgreSQL を含むサービス群を稼働させている。今回のスキャン記録もその構成を活用し、PostgreSQL に所在履歴を追記するテーブルや、既存 UI への表示追加を想定する（リポジトリ改修時は必ず新しいブランチで作業）。

## 12. サイネージ連携（ウィンドウC）留意点
- ECG（RaspberryPizero2W_withDropbox）側でサイネージ表示を構築済み。OnSiteLogistics はスキャン結果をローカルサーバーへ集約するのみとし、サイネージとは API やファイル共有など最小限の引き渡し方法を協議（例: サーバーが CSV/JSON を共有ドロップボックスへ出力）。
- 今後の調整事項:
  - サーバー側で生成するデータ形式・更新頻度。
  - サイネージ側が要求するフィールド（部品名、棚、タイムスタンプ、アラートなど）。
  - ネットワーク分離ポリシー（Wi-Fi 経由での直接参照か、Dropbox 等の間接共有か）。
## 10. 次のアクション案
- サイネージ表示要件の整理（表示項目・優先順位・更新頻度）とワイヤフレーム作成。
- `part_location_updated` イベントを購読するサイネージ実装方針（Socket.IO クライアント vs REST フォールバック）の比較検討。
- サーバー側からサイネージ向けに提供するデータ構造・API/共有ファイル設計とラズパイ Window C への受け渡し手順の確定。
- API トークンの用途別運用（HANDHELD-* / SIGNAGE-*）とローテーション手順を RUNBOOK / `docs/handheld-reader.md` に反映。
